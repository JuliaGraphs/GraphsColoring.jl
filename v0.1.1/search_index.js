var documenterSearchIndex = {"docs":
[{"location":"apiref/#API-Reference","page":"API Reference","title":"API Reference","text":"","category":"section"},{"location":"apiref/","page":"API Reference","title":"API Reference","text":"","category":"page"},{"location":"apiref/#GraphsColoring.WorkstreamDSATUR","page":"API Reference","title":"GraphsColoring.WorkstreamDSATUR","text":"const WorkstreamDSATUR = Workstream(DSATUR())\n\nA workstream that uses the DSATUR coloring algorithm.\n\n\n\n\n\n","category":"constant"},{"location":"apiref/#GraphsColoring.WorkstreamGreedy","page":"API Reference","title":"GraphsColoring.WorkstreamGreedy","text":"const WorkstreamGreedy = Workstream(Greedy())\n\nA workstream that uses the Greedy coloring algorithm.\n\n\n\n\n\n","category":"constant"},{"location":"apiref/#GraphsColoring.ConflictFunctor","page":"API Reference","title":"GraphsColoring.ConflictFunctor","text":"struct ConflictFunctor{T}\n    conflictindices::T\n\nA functor that can be used to return conflict indices.\n\nType Parameters\n\nT: The type of the conflict indices.\n\nFields\n\nconflictindices::T: The conflict indices.\n\nThis functor represents a mapping from element indices to conflict indices. Two elements that have the same conflict index are considered to be in conflict. An element can have multiple conflict indices, indicating that it is in conflict with multiple other elements.\n\n\n\n\n\n","category":"type"},{"location":"apiref/#GraphsColoring.ConflictFunctor-Tuple{Int64}","page":"API Reference","title":"GraphsColoring.ConflictFunctor","text":"function (f::ConflictFunctor)(i::Int)\n\nReturns the conflict indices for the given element index.\n\nArguments\n\nf::ConflictFunctor: The conflict functor.\ni::Int: The element index.\n\nReturns\n\nThe conflict indices for the given element index.\n\n\n\n\n\n","category":"method"},{"location":"apiref/#GraphsColoring.DSATUR","page":"API Reference","title":"GraphsColoring.DSATUR","text":"struct DSATUR\n\nRepresents the DSATUR (Degree SATURated) coloring algorithm, which makes use of two key concepts:\n\nDegree of a node: The number of neighbors a node has.\nSaturation of a node: The number of colors already assigned to its neighbors.\n\nThe next node to be colored is chosen based on the following criteria:\n\nHighest saturation degree: The node with the highest saturation degree is chosen first.\nLargest degree: In case of a tie, the node with the largest degree is chosen.\nLargest element ID: If there is still a tie, the node with the largest element ID is chosen.\n\n\n\n\n\n","category":"type"},{"location":"apiref/#GraphsColoring.DSATURNode","page":"API Reference","title":"GraphsColoring.DSATURNode","text":"struct DSATURNode\n    elementid::Int\n    degree::Int\n    saturation::Int\n\nRepresents a node in the context of the DSATUR coloring algorithm.\n\nFields\n\nelementid::Int: The unique identifier of the element.\ndegree::Int: The number of neighbors the element has.\nsaturation::Int: The number of colors already assigned to the neighboring elements.\n\nThis node is used in a RBTree from DataStructures.jl to efficiently manage and prioritize nodes during the coloring process.\n\n\n\n\n\n","category":"type"},{"location":"apiref/#GraphsColoring.Greedy","page":"API Reference","title":"GraphsColoring.Greedy","text":"struct Greedy\n\nRepresents the Greedy coloring algorithm, where the next node to be colored is chosen as the node with the largest element ID.\n\n\n\n\n\n","category":"type"},{"location":"apiref/#GraphsColoring.GreedyNode","page":"API Reference","title":"GraphsColoring.GreedyNode","text":"struct GreedyNode\n\nRepresents a node in the context of the Greedy coloring algorithm.\n\nFields\n\nelementid::Int: The unique identifier of the element.\n\nThis node type is used by the Greedy algorithm to make coloring decisions, where the next node to be colored is chosen based on its element ID.\n\n\n\n\n\n","category":"type"},{"location":"apiref/#GraphsColoring.PassThroughConflictFunctor","page":"API Reference","title":"GraphsColoring.PassThroughConflictFunctor","text":"struct PassThroughConflictFunctor{E,C1,C2}\n\nA functor that passes through elements, conflicts, and conflict IDs for the conflicts function.\n\nFields\n\nelements::E: The elements to be passed through.\nconflicts::C1: The conflicts to be passed through.\nconflictids::C2: The conflict IDs to be passed through.\n\n\n\n\n\n","category":"type"},{"location":"apiref/#GraphsColoring.Workstream","page":"API Reference","title":"GraphsColoring.Workstream","text":"struct Workstream{T}\n    algorithm::T\n\nRepresents the workstream coloring algorithm presented in [1].\n\nType Parameters\n\nT: The type of the coloring algorithm.\n\nFields\n\nalgorithm::T: The coloring algorithm used by the workstream.\n\nThis struct represents the workstream coloring algorithm, which does not create the minimal amount of colors, but is very good at creating balanced colors. Balanced colors are important for load balancing in parallel computing. It uses the partition, color, and gather steps to perform coloring. In the color step, the algorithm is used for internal coloring. Only coloring all elements is supported.\n\nSee [1] for more information on the workstream design pattern.\n\n[1] B. Turcksin, M. Kronbichler, and W. Bangerth, WorkStream – A Design Pattern for Multicore-Enabled Finite Element Computations, 2017\n\n\n\n\n\n","category":"type"},{"location":"apiref/#GraphsColoring._neighbors-Tuple{SparseArrays.SparseMatrixCSC, Int64}","page":"API Reference","title":"GraphsColoring._neighbors","text":"function _neighbors(s::SparseMatrixCSC, element::Int)\n\nReturns the neighbors of a given element, i.e. the elements that have a conflict with the element, in the sparse matrix, which is used as a conflict representation.\n\nArguments\n\ns::SparseMatrixCSC: The sparse matrix representing the graph.\nelement::Int: The element for which to retrieve the neighbors.\n\nReturns\n\nA view of the row values in the sparse matrix that correspond to the neighbors of the given element.\n\n\n\n\n\n","category":"method"},{"location":"apiref/#GraphsColoring._numelements-Tuple{SparseArrays.SparseMatrixCSC}","page":"API Reference","title":"GraphsColoring._numelements","text":"function _numelements(s::SparseMatrixCSC)\n\nReturns the number of elements in the given sparse matrix, which is used as a conflict representation.\n\nArguments\n\ns::SparseMatrixCSC: The sparse matrix.\n\nReturns\n\nThe number of rows in the matrix, which represents the number of elements.\n\n\n\n\n\n","category":"method"},{"location":"apiref/#GraphsColoring.color","page":"API Reference","title":"GraphsColoring.color","text":"function color(conflicts, algorithm, elements=1:_numelements(conflicts))\n\nPerforms graph coloring using the specified algorithm.\n\nArguments\n\nconflicts: The conflict representation.\nalgorithm: The coloring algorithm to use (e.g., DSATUR, Greedy).\nelements: The elements to consider during coloring (default: all elements).\n\nReturns\n\nA vector of vectors, where each inner vector represents a color (i.e., a set of elements with the same color). Elements in the same color do not have any conflict. The colors are sorted such that the number of their members decrease.\n\nThis function implements a generic coloring workflow that can be used with different algorithms, such as DSATUR and Greedy.\n\n\n\n\n\n","category":"function"},{"location":"apiref/#GraphsColoring.color-2","page":"API Reference","title":"GraphsColoring.color","text":"function color(conflicts, algorithm::Workstream, elements=1:_numelements(conflicts))\n\nPerforms workstream coloring on the given conflicts. It was presented in [1]. Workstream coloring does not create the minimal amount of colors, but is very good at creating balanced colors. Balanced colors are important for load balancing in parallel computing. It uses the partition, color, and gather steps to perform coloring.\n\nArguments\n\nconflicts: The conflict representation.\nalgorithm::Workstream: The workstream coloring algorithm.\nelements=1:_numelements(conflicts): The elements to consider during coloring (default: all elements).\n\nReturns\n\nA vector of vectors, where each inner vector represents a color.\n\nNote that workstream coloring only supports coloring all elements, so the elements argument must be equal to 1:_numelements(conflicts).\n\nSee [1] for more information on the workstream design pattern.\n\n[1] B. Turcksin, M. Kronbichler, and W. Bangerth, WorkStream – A Design Pattern for Multicore-Enabled Finite Element Computations, 2017\n\n\n\n\n\n","category":"function"},{"location":"apiref/#GraphsColoring.color-Tuple{Any}","page":"API Reference","title":"GraphsColoring.color","text":"color(conflicts; algorithm=Workstream(DSATUR()))\n\nColors the elements in the conflict representation such that elements in the same color do not have any conflicts.\n\nArguments\n\nconflicts: The conflict representation.\nalgorithm: The coloring algorithm to use. Defaults to Workstream(DSATUR()).\n\nReturns\n\nA Vector{Vector{Int}} where each inner Vector represents the elements of one color.\n\n\n\n\n\n","category":"method"},{"location":"apiref/#GraphsColoring.colorzones-Tuple{Any, Any, Any}","page":"API Reference","title":"GraphsColoring.colorzones","text":"function colorzones(conflicts, zones, algorithm)\n\nColors the elements within each zone using the specified algorithm.\n\nArguments\n\nconflicts: The conflict representation.\nzones: A vector of sets, where each set represents a zone.\nalgorithm: The coloring algorithm to use (e.g., DSATUR, Greedy).\n\nReturns\n\nA vector of vectors of vectors, where each innermost vector represents a color class within a zone.\n\nThis function applies the color function to each zone independently, using the specified algorithm to color the elements within that zone.\n\n\n\n\n\n","category":"method"},{"location":"apiref/#GraphsColoring.conflictgraph","page":"API Reference","title":"GraphsColoring.conflictgraph","text":"conflictgraph\n\n\n\n\n\n","category":"function"},{"location":"apiref/#GraphsColoring.conflictmatrix-Tuple{Any}","page":"API Reference","title":"GraphsColoring.conflictmatrix","text":"function conflictmatrix(X; kwargs...)\n\nComputes a sparse matrix as a conflict representation.\n\nArguments\n\nX: An object that supports the conflicts function.\nkwargs...: Additional keyword arguments that are passed to the conflicts function.\n\nReturns\n\nA sparse matrix representing the conflicts between elements, where each entry (i, j) represents a conflict between elements i and j. Note that this matrix is symmetric.\n\n\n\n\n\n","category":"method"},{"location":"apiref/#GraphsColoring.conflicts","page":"API Reference","title":"GraphsColoring.conflicts","text":"function conflicts\n\n\n\n\n\n","category":"function"},{"location":"apiref/#GraphsColoring.conflicts-Tuple{PassThroughConflictFunctor}","page":"API Reference","title":"GraphsColoring.conflicts","text":"conflicts(f::PassThroughConflictFunctor; kwargs...)\n\nReturns the elements, conflicts, and conflict IDs of the functor.\n\n\n\n\n\n","category":"method"},{"location":"apiref/#GraphsColoring.gather-Tuple{Any, Any}","page":"API Reference","title":"GraphsColoring.gather","text":"function gather(oddcoloredzones, evencoloredzones)\n\nGathers and combines the colors of the odd and even zones.\n\nArguments\n\noddcoloredzones: A vector of vectors, where each inner vector represents a color class within an odd zone.\nevencoloredzones: A vector of vectors, where each inner vector represents a color class within an even zone.\n\nReturns\n\nA vector of vectors, where each inner vector represents a combined color with elements from both odd and even zones. The colors are sorted in decreasing order by the number of their members.\n\nThis function works by first gathering the colors within each set of zones (odd and even) using the gather function, and then combining the results. The combined colors are then sorted in decreasing order by the number of their members.\n\n\n\n\n\n","category":"method"},{"location":"apiref/#GraphsColoring.gather-Tuple{Any}","page":"API Reference","title":"GraphsColoring.gather","text":"function gather(coloredzones)\n\nGathers elements from all zones to create larger colors.\n\nArguments\n\ncoloredzones: A vector of vectors, where each inner vector represents a color class within a zone.\n\nReturns\n\nA vector of vectors, where each inner vector represents a color class with elements from all zones. The colors are sorted in decreasing order by the number of their members.\n\nThis function works by first selecting the zone with the most colors (the \"master zone\") and using its colors as the initial set. It then iterates over the remaining zones, appending their colors to the corresponding colors in the master zone. Finally, the colors are sorted in decreasing order by the number of their members.\n\n\n\n\n\n","category":"method"},{"location":"apiref/#GraphsColoring.initializealgorithminfo-Tuple{Any, Any, DSATUR}","page":"API Reference","title":"GraphsColoring.initializealgorithminfo","text":"function initializealgorithminfo(conflicts, elements, ::DSATUR)\n\nInitializes the algorithm-specific information for the DSATUR coloring algorithm.\n\nArguments\n\nconflicts: The conflict representation.\nelements: The list of elements to be colored.\n::DSATUR: The DSATUR algorithm specifier.\n\nReturns\n\nA named tuple containing the following fields:\n\ndegrees: A vector of integers representing the degree of each element (i.e., the number of neighbors).\nsaturations: A vector of integers representing the saturation of each element (i.e., the number of colors already assigned to its neighbors), initialized to zero.\n\nThis function is used to set up the initial state of the DSATUR algorithm, which relies on the degrees and saturations of the elements to make coloring decisions.\n\n\n\n\n\n","category":"method"},{"location":"apiref/#GraphsColoring.initializealgorithminfo-Tuple{Any, Any, Greedy}","page":"API Reference","title":"GraphsColoring.initializealgorithminfo","text":"function initializealgorithminfo(::Any, ::Any, ::Greedy)\n\nInitializes the algorithm-specific information for the Greedy coloring algorithm.\n\nArguments\n\n::Any: Unused arguments (placeholders for other algorithms).\n::Any: Unused arguments (placeholders for other algorithms).\n::Greedy: The Greedy algorithm specifier.\n\nReturns\n\nnothing, indicating that no additional information is needed for the Greedy algorithm to make coloring decisions.\n\n\n\n\n\n","category":"method"},{"location":"apiref/#GraphsColoring.noconflicts-Tuple{SparseArrays.SparseMatrixCSC}","page":"API Reference","title":"GraphsColoring.noconflicts","text":"function noconflicts(s::SparseMatrixCSC)\n\nChecks if there are no conflicts in the given sparse matrix, which is used as a conflict representation.\n\nArguments\n\ns::SparseMatrixCSC: The sparse matrix to check.\n\nReturns\n\ntrue if there are no conflicts (i.e., the matrix has no non-zero entries), and false otherwise.\n\n\n\n\n\n","category":"method"},{"location":"apiref/#GraphsColoring.node-Tuple{Any, Any, Any, DSATUR}","page":"API Reference","title":"GraphsColoring.node","text":"function node(element, elementid, algorithminfo, ::DSATUR)\n\nCreates a new node for the DSATUR coloring algorithm.\n\nArguments\n\nelement: The element to be represented by the node.\nelementid: The local ID of the element.\nalgorithminfo: The named tuple containing the algorithm-specific information (degrees and saturations).\n::DSATUR: The DSATUR algorithm specifier.\n\nReturns\n\nA new DSATURNode instance with the following fields:\n\nelementid: The global ID of the element (note: this field is actually set to the element itself, not the elementid).\ndegree: The current degree of the element.\nsaturation: The current saturation of the element.\n\n\n\n\n\n","category":"method"},{"location":"apiref/#GraphsColoring.node-Tuple{Any, Any, Any, Greedy}","page":"API Reference","title":"GraphsColoring.node","text":"function node(element, ::Any, ::Any, ::Greedy)\n\nCreates a new node for the Greedy coloring algorithm.\n\nArguments\n\nelement: The element to be represented by the node.\n::Any: Unused arguments (placeholders for other algorithms).\n::Any: Unused arguments (placeholders for other algorithms).\n::Greedy: The Greedy algorithm specifier.\n\nReturns\n\nA new node instance representing the element, which is used by the Greedy algorithm to make coloring decisions.\n\nNote: The Greedy algorithm does not require any additional information beyond the element itself, so the node is created with only the element.\n\n\n\n\n\n","category":"method"},{"location":"apiref/#GraphsColoring.nodetype-Tuple{DSATUR}","page":"API Reference","title":"GraphsColoring.nodetype","text":"function nodetype(::DSATUR)\n\nReturns the node type used by the DSATUR coloring algorithm.\n\nArguments\n\n::DSATUR: The DSATUR algorithm specifier.\n\nReturns\n\nThe DSATURNode type, which represents a node with an element ID, degree, and saturation.\n\n\n\n\n\n","category":"method"},{"location":"apiref/#GraphsColoring.nodetype-Tuple{Greedy}","page":"API Reference","title":"GraphsColoring.nodetype","text":"function nodetype(::Greedy)\n\nReturns the node type used by the Greedy coloring algorithm.\n\nArguments\n\n::Greedy: The Greedy algorithm specifier.\n\nReturns\n\nThe GreedyNode type, which represents a node used by the Greedy algorithm to make coloring decisions.\n\n\n\n\n\n","category":"method"},{"location":"apiref/#GraphsColoring.partition-Tuple{Any}","page":"API Reference","title":"GraphsColoring.partition","text":"function partition(conflicts)\n\nPartitions the elements into two sets of zones: even and odd zones.\n\nArguments\n\nconflicts: The conflict representation.\n\nReturns\n\nA tuple of two vectors of sets, where each set represents a zone. The first vector contains the odd zones, and the second vector contains the even zones.\n\nThe partitioning is done such that there are no conflicts between elements of an odd zone and elements of another odd zone (and similarly for even zones). However, there may be conflicts between elements within the same zone.\n\n\n\n\n\n","category":"method"},{"location":"apiref/#GraphsColoring.reverseconflicts-Tuple{Any, Any, Any}","page":"API Reference","title":"GraphsColoring.reverseconflicts","text":"function reverseconflicts(elements, conflicts, conflictids)\n\nReverses the conflict indices and elements.\n\nArguments\n\nelements: The elements.\nconflicts: A function that takes an element and returns its conflict indices.\nconflictids: The conflict IDs.\n\nReturns\n\nA vector of vectors, where each inner vector represents the elements which have a certain conflict index.\n\n\n\n\n\n","category":"method"},{"location":"apiref/#GraphsColoring.updateinfo!-Tuple{Any, Any, Any, DSATUR}","page":"API Reference","title":"GraphsColoring.updateinfo!","text":"function updateinfo!(::Any, elementid, algorithminfo, ::DSATUR)\n\nUpdates the algorithm-specific information for the DSATUR coloring algorithm after an element has been colored.\n\nArguments\n\n::Any: Unused argument (a placeholder for other algorithms, that need the global elementid).\nelementid: The local ID of the element that has been colored.\nalgorithminfo: The named tuple containing the algorithm-specific information (degrees and saturations).\n::DSATUR: The DSATUR algorithm specifier.\n\nReturns\n\nThe updated algorithminfo named tuple.\n\nThis function updates the degree and saturation of the colored element by:\n\nDecrementing its degree by 1, since once of its neighbors is no longer available for coloring.\nIncrementing its saturation by 1, since a color has been assigned to one of its neighbors.\n\n\n\n\n\n","category":"method"},{"location":"apiref/#GraphsColoring.updateinfo!-Tuple{Any, Any, Any, Greedy}","page":"API Reference","title":"GraphsColoring.updateinfo!","text":"function updateinfo!(::Any, ::Any, ::Any, ::Greedy)\n\nUpdates the algorithm-specific information for the Greedy coloring algorithm.\n\nArguments\n\n::Any: Unused arguments (placeholders for other algorithms).\n::Any: Unused arguments (placeholders for other algorithms).\n::Any: Unused arguments (placeholders for other algorithms).\n::Greedy: The Greedy algorithm specifier.\n\nReturns\n\nnothing, indicating that no update is needed for the Greedy algorithm, as it does not maintain any internal state.\n\n\n\n\n\n","category":"method"},{"location":"apiref/#GraphsColoring._neighbors-Tuple{AbstractGraph, Int64}","page":"API Reference","title":"GraphsColoring._neighbors","text":"function _neighbors(g::AbstractGraph, element::Int)\n\nReturns the neighbors of a given element, i.e. the elements that have a conflict with the element, in the AbstractGraph, which is used as a conflict representation.\n\nArguments\n\ng::AbstractGraph: The graph.\nelement::Int: The element for which to retrieve the neighbors.\n\nReturns\n\nThe neighbors of the given element.\n\n\n\n\n\n","category":"method"},{"location":"apiref/#GraphsColoring._numelements-Tuple{AbstractGraph}","page":"API Reference","title":"GraphsColoring._numelements","text":"function _numelements(g::AbstractGraph)\n\nReturns the number of elements in the graph.\n\nArguments\n\ng::AbstractGraph: The graph.\n\nReturns\n\nThe number of elements in the graph.\n\n\n\n\n\n","category":"method"},{"location":"apiref/#GraphsColoring.conflictgraph-Tuple{Any}","page":"API Reference","title":"GraphsColoring.conflictgraph","text":"function conflictgraph(X; kwargs...)\n\nCreates a conflict graph as a SimpleGraph from Graphs.jl.\n\nArguments\n\nX: An object that supports the conflictmatrix function.\nkwargs...: Additional keyword arguments that are passed to the conflictmatrix function.\n\nReturns\n\nA SimpleGraph representing the conflict graph.\n\nThis function works by first computing the conflict matrix using the conflictmatrix function, and then creating a SimpleGraph from the matrix.\n\n\n\n\n\n","category":"method"},{"location":"apiref/#GraphsColoring.noconflicts-Tuple{AbstractGraph}","page":"API Reference","title":"GraphsColoring.noconflicts","text":"function noconflicts(g::AbstractGraph)\n\nChecks if there are no conflicts in the given graph.\n\nArguments\n\ng::AbstractGraph: The graph to check.\n\nReturns\n\ntrue if there are no conflicts (i.e., there are no edges in the graph), and false otherwise.\n\n\n\n\n\n","category":"method"},{"location":"contributing/#Contributing","page":"Contributing","title":"Contributing","text":"","category":"section"},{"location":"contributing/","page":"Contributing","title":"Contributing","text":"In order to contribute to this package directly create a pull request against the main branch. Before doing so please:  ","category":"page"},{"location":"contributing/","page":"Contributing","title":"Contributing","text":"Follow the style of the surrounding code.\nSupplement the documentation.\nWrite tests and check that no errors occur.","category":"page"},{"location":"contributing/","page":"Contributing","title":"Contributing","text":"","category":"page"},{"location":"contributing/#Style","page":"Contributing","title":"Style","text":"","category":"section"},{"location":"contributing/","page":"Contributing","title":"Contributing","text":"For a consistent style the JuliaFormatter.jl package is used which enforces the style defined in the .JuliaFormatter.toml file. To follow this style simply run","category":"page"},{"location":"contributing/","page":"Contributing","title":"Contributing","text":"using JuliaFormatter\nformat(pkgdir(GraphsColoring; overwrite=true))","category":"page"},{"location":"contributing/","page":"Contributing","title":"Contributing","text":"note: Note\nThat all files follow the JuliaFormatter style is tested during the unit tests. Hence, do not forget to execute the two lines above. Otherwise, the tests are likely to not pass.","category":"page"},{"location":"contributing/","page":"Contributing","title":"Contributing","text":"","category":"page"},{"location":"contributing/#Documentation","page":"Contributing","title":"Documentation","text":"","category":"section"},{"location":"contributing/","page":"Contributing","title":"Contributing","text":"Add documentation for any changes or new features following the style of the existing documentation. For more information you can have a look at the Documenter.jl documentation.","category":"page"},{"location":"contributing/","page":"Contributing","title":"Contributing","text":"","category":"page"},{"location":"contributing/#Tests","page":"Contributing","title":"Tests","text":"","category":"section"},{"location":"contributing/","page":"Contributing","title":"Contributing","text":"Write tests for your code changes and verify that no errors occur, e.g., by running","category":"page"},{"location":"contributing/","page":"Contributing","title":"Contributing","text":"using Pkg\nPkg.test(\"GraphsColoring\")","category":"page"},{"location":"contributing/","page":"Contributing","title":"Contributing","text":"For more detailed information on which parts are tested the coverage can be evaluated on your local machine, e.g., by","category":"page"},{"location":"contributing/","page":"Contributing","title":"Contributing","text":"using Pkg\nPkg.test(\"GraphsColoring\"; coverage=true, julia_args=`--threads 6`)\n\n# determine coverage\nusing Coverage\nsrc_folder = pkgdir(GraphsColoring) * \"/src\"\ncoverage   = process_folder(src_folder)\nLCOV.writefile(\"path-to-folder-you-like\" * \"GraphsColoring.lcov.info\", coverage)\n\nclean_folder(src_folder) # delete .cov files\n\n# extract information about coverage\ncovered_lines, total_lines = get_summary(coverage)\n@info \"Current coverage:\\n$covered_lines of $total_lines lines ($(round(Int, covered_lines / total_lines * 100)) %)\"","category":"page"},{"location":"contributing/","page":"Contributing","title":"Contributing","text":"In Visual Studio Code the Coverage Gutters plugin can be used to visualize the tested lines of the code by inserting the path of the GraphsColoring.lcov.info file in the settings.","category":"page"},{"location":"dsatur/#DSatur","page":"DSatur","title":"DSatur","text":"","category":"section"},{"location":"dsatur/","page":"DSatur","title":"DSatur","text":"Represents the DSATUR (Degree SATURated) coloring algorithm, which makes use of two key concepts:","category":"page"},{"location":"dsatur/","page":"DSatur","title":"DSatur","text":"Degree of a node: The number of neighbors a node has.\nSaturation of a node: The number of colors already assigned to its neighbors.","category":"page"},{"location":"dsatur/","page":"DSatur","title":"DSatur","text":"The next node to be colored is chosen based on the following criteria:","category":"page"},{"location":"dsatur/","page":"DSatur","title":"DSatur","text":"Highest saturation degree: The node with the highest saturation degree is chosen first.\nLargest degree: In case of a tie, the node with the largest degree is chosen.\nLargest element ID: If there is still a tie, the node with the largest element ID is chosen.","category":"page"},{"location":"dsatur/","page":"DSatur","title":"DSatur","text":"This algorithm often creates less colors than the Greedy algorithm. The colors are not guaranteed to be balanced.","category":"page"},{"location":"dsatur/#Usage-example","page":"DSatur","title":"Usage example","text":"","category":"section"},{"location":"dsatur/","page":"DSatur","title":"DSatur","text":"using PlotlyJS\nusing CompScienceMeshes\nusing BEAST\nusing GraphsColoring\n\nm = meshsphere(1.0, 0.1)\nX = raviartthomas(m)\n\nconflicts = GraphsColoring.conflictmatrix(X)\n\ncolors = GraphsColoring.color(conflicts; algorithm=DSATUR())\n\nfor (i, color) in enumerate(colors)\n    println(\"Color $i has $(length(color)) elements\")\nend\n\nfacecolors = zeros(size(conflicts, 1))\n\nfor (i, color) in enumerate(colors)\n    for element in color\n        facecolors[element] = i\n    end\nend\n\np = PlotlyJS.plot(\n    patch(m, facecolors; showscale=false),\n    Layout(;\n        scene=attr(;\n            xaxis=attr(; visible=false),\n            yaxis=attr(; visible=false),\n            zaxis=attr(; visible=false),\n        ),\n    );\n)\n\nsavefig(p, \"color_dsatur_ball.html\"); # hide\nnothing #hide","category":"page"},{"location":"dsatur/","page":"DSatur","title":"DSatur","text":"<object data=\"../color_dsatur_ball.html\" type=\"text/html\"  style=\"width:100%; height:50vh;\"> </object>","category":"page"},{"location":"greedy/#Greedy","page":"Greedy","title":"Greedy","text":"","category":"section"},{"location":"greedy/","page":"Greedy","title":"Greedy","text":"Represents the Greedy coloring algorithm, where each node is colred subsequentently. The next node to be colored is chosen as the node with the largest element ID.","category":"page"},{"location":"greedy/","page":"Greedy","title":"Greedy","text":"The colors are not guaranteed to be balanced.","category":"page"},{"location":"greedy/#Usage-example","page":"Greedy","title":"Usage example","text":"","category":"section"},{"location":"greedy/","page":"Greedy","title":"Greedy","text":"using PlotlyJS\nusing CompScienceMeshes\nusing BEAST\nusing GraphsColoring\n\nm = meshsphere(1.0, 0.1)\nX = raviartthomas(m)\n\nconflicts = GraphsColoring.conflictmatrix(X)\n\ncolors = GraphsColoring.color(conflicts; algorithm=Greedy())\n\nfor (i, color) in enumerate(colors)\n    println(\"Color $i has $(length(color)) elements\")\nend\n\nfacecolors = zeros(size(conflicts, 1))\n\nfor (i, color) in enumerate(colors)\n    for element in color\n        facecolors[element] = i\n    end\nend\n\np = PlotlyJS.plot(\n    patch(m, facecolors; showscale=false),\n    Layout(;\n        scene=attr(;\n            xaxis=attr(; visible=false),\n            yaxis=attr(; visible=false),\n            zaxis=attr(; visible=false),\n        ),\n    );\n)\n\nsavefig(p, \"color_greedy_ball.html\"); # hide\nnothing #hide","category":"page"},{"location":"greedy/","page":"Greedy","title":"Greedy","text":"<object data=\"../color_greedy_ball.html\" type=\"text/html\"  style=\"width:100%; height:50vh;\"> </object>","category":"page"},{"location":"workstream/#Workstream","page":"Workstream","title":"Workstream","text":"","category":"section"},{"location":"workstream/","page":"Workstream","title":"Workstream","text":"The Workstream coloring algorithm is presented in [1].","category":"page"},{"location":"workstream/","page":"Workstream","title":"Workstream","text":"The Workstream coloring algorithm does not have the goal to create the minimal amount of colors, but is very good at creating balanced colors. Balanced colors are important for load balancing in parallel computing. The algorithm consists of the following steps:","category":"page"},{"location":"workstream/","page":"Workstream","title":"Workstream","text":"partition\nThe elements are partitioned into two sets of zones: even and odd zones.  The partitioning is done such that there are no conflicts between elements of an odd zone  and elements of another odd zone (and similarly for even zones).  However, there may be conflicts between elements within the same zone.\ncolor\nThe colorzones colors the elements within each zone using a specified algorithm.\ngather\nFor the even and odd zones, respectively, the gather step selects the zone with the most colors (the \"master zone\") and uses its colors as the initial set.  It then iterates over the remaining zones, appending their colors to the corresponding  colors in the master zone to create larger colors.  Finally, the colors are sorted in decreasing order by the number of their members.","category":"page"},{"location":"workstream/","page":"Workstream","title":"Workstream","text":"See [1] for more information on the Workstream design pattern.","category":"page"},{"location":"workstream/","page":"Workstream","title":"Workstream","text":"[1] B. Turcksin, M. Kronbichler, and W. Bangerth, WorkStream – A Design Pattern for Multicore-Enabled Finite Element Computations, 2017","category":"page"},{"location":"workstream/#Usage-example-I","page":"Workstream","title":"Usage example I","text":"","category":"section"},{"location":"workstream/","page":"Workstream","title":"Workstream","text":"using PlotlyJS\nusing CompScienceMeshes\nusing BEAST\nusing GraphsColoring\n\nm = meshsphere(1.0, 0.1)\nX = raviartthomas(m)\n\nconflicts = GraphsColoring.conflictmatrix(X)\n\ncolors = GraphsColoring.color(conflicts; algorithm=WorkstreamDSATUR)\n\nfor (i, color) in enumerate(colors)\n    println(\"Color $i has $(length(color)) elements\")\nend\n\nfacecolors = zeros(size(conflicts, 1))\n\nfor (i, color) in enumerate(colors)\n    for element in color\n        facecolors[element] = i\n    end\nend\n\np = PlotlyJS.plot(\n    patch(m, facecolors; showscale=false),\n    Layout(;\n        scene=attr(;\n            xaxis=attr(; visible=false),\n            yaxis=attr(; visible=false),\n            zaxis=attr(; visible=false),\n        ),\n    );\n)\n\nsavefig(p, \"color_workstreamdsatur_ball.html\"); # hide\nnothing #hide","category":"page"},{"location":"workstream/","page":"Workstream","title":"Workstream","text":"<object data=\"../color_workstreamdsatur_ball.html\" type=\"text/html\"  style=\"width:100%; height:50vh;\"> </object>","category":"page"},{"location":"workstream/#Usage-example-II","page":"Workstream","title":"Usage example II","text":"","category":"section"},{"location":"workstream/","page":"Workstream","title":"Workstream","text":"Instead of the DSATUR algorithm we can also use the Greedy algorithm in the color step.","category":"page"},{"location":"workstream/","page":"Workstream","title":"Workstream","text":"using PlotlyJS#hide\nusing CompScienceMeshes#hide\nusing BEAST#hide\nusing GraphsColoring#hide\n\nm = meshsphere(1.0, 0.1)#hide\nX = raviartthomas(m)#hide\n\nconflicts = GraphsColoring.conflictmatrix(X)#hide\n\ncolors = GraphsColoring.color(conflicts; algorithm=WorkstreamGreedy)\n\nfor (i, color) in enumerate(colors)#hide\n    println(\"Color $i has $(length(color)) elements\")#hide\nend#hide\n\nfacecolors = zeros(size(conflicts, 1))#hide\n\nfor (i, color) in enumerate(colors)#hide\n    for element in color#hide\n        facecolors[element] = i#hide\n    end#hide\nend #hide\n\np = PlotlyJS.plot(#hide\n    patch(m, facecolors; showscale=false),#hide\n    Layout(;#hide\n        scene=attr(;#hide\n            xaxis=attr(; visible=false),#hide\n            yaxis=attr(; visible=false),#hide\n            zaxis=attr(; visible=false),#hide\n        ),#hide\n    );#hide\n)#hide\n\nsavefig(p, \"color_workstreamgreedy_ball.html\"); # hide\nnothing #hide","category":"page"},{"location":"workstream/","page":"Workstream","title":"Workstream","text":"<object data=\"../color_workstreamgreedy_ball.html\" type=\"text/html\"  style=\"width:100%; height:50vh;\"> </object>","category":"page"},{"location":"conflicts/#Conflicts","page":"Conflicts","title":"Conflicts","text":"","category":"section"},{"location":"conflicts/","page":"Conflicts","title":"Conflicts","text":"A conflict representation is a data structure that captures the conflicts between elements in a graph. In the context of parallel computing, for example, conflicts occur when two elements share a common resource, such as a memory location.","category":"page"},{"location":"conflicts/","page":"Conflicts","title":"Conflicts","text":"Two elements are in conflict if they share a common conflict index. For example, in a parallel computation, two elements may conflict if they both attempt to access the same index of a vector.","category":"page"},{"location":"conflicts/","page":"Conflicts","title":"Conflicts","text":"A conflict representation must implement the following functions:","category":"page"},{"location":"conflicts/","page":"Conflicts","title":"Conflicts","text":"_neighbors: Returns a list of elements that are in conflict with the given element.\n_numelements: Returns the total number of elements in the conflict representation.\nnoconflicts: Returns a boolean indicating whether there occurs any conflict in the whole representation.","category":"page"},{"location":"conflicts/","page":"Conflicts","title":"Conflicts","text":"It is possible to have a SparseMatrixCSC from SparseArrays or a SimpleGraph from Graphs.jl as a conflict representation. The graph conflict representation is tied to GraphsColoring as an extension depending on  Graphs.jl.","category":"page"},{"location":"conflicts/","page":"Conflicts","title":"Conflicts","text":"The respective representation needs to support the conflicts function that returns","category":"page"},{"location":"conflicts/","page":"Conflicts","title":"Conflicts","text":"elements: The elements.\nconflicts: A function that takes an element and returns its conflict indices. The ConflictFunctor can be used for this.\nconflictids: The conflict IDs.","category":"page"},{"location":"conflicts/","page":"Conflicts","title":"Conflicts","text":"using CompScienceMeshes\nusing BEAST\nusing GraphsColoring\n\nm = meshsphere(1.0, 0.1)\nX = raviartthomas(m)\n\nconflicts = GraphsColoring.conflicts(X)","category":"page"},{"location":"conflicts/#Sparse-matrix-as-conflict-representation","page":"Conflicts","title":"Sparse matrix as conflict representation","text":"","category":"section"},{"location":"conflicts/","page":"Conflicts","title":"Conflicts","text":"using CompScienceMeshes\nusing BEAST\nusing GraphsColoring\n\nm = meshsphere(1.0, 0.1)\nX = raviartthomas(m)\n\nconflicts = GraphsColoring.conflictmatrix(X)","category":"page"},{"location":"conflicts/#Graph-as-conflict-representation","page":"Conflicts","title":"Graph as conflict representation","text":"","category":"section"},{"location":"conflicts/","page":"Conflicts","title":"Conflicts","text":"using CompScienceMeshes\nusing BEAST\nusing Graphs\nusing GraphsColoring\n\nm = meshsphere(1.0, 0.1)\nX = raviartthomas(m)\n\nconflicts = GraphsColoring.conflictgraph(X)\nprintln(typeof(conflicts))","category":"page"},{"location":"#GraphsColoring","page":"Home","title":"GraphsColoring","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Graph coloring is a technique used to avoid conflicts between elements in a graph. The goal is to assign colors to the elements such that no two neighboring elements have the same color. Currently, the following aspects are implemented (✓) and planned (⌛):","category":"page"},{"location":"","page":"Home","title":"Home","text":"✓ Greedy\n✓ DSATUR (Degree SATURated)\n✓ Workstream\n⌛ Random (and iterative random coloring)\n⌛ First-Fit Coloring","category":"page"},{"location":"#Related-packages","page":"Home","title":"Related packages","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The GraphsColoring package is related to the following packages:","category":"page"},{"location":"","page":"Home","title":"Home","text":"BEAST\nGraphs.jl","category":"page"},{"location":"#Documentation","page":"Home","title":"Documentation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"This documentation provides an overview of the GraphsColoring package, including its features, goals, and related packages. For more information, please see the individual documentation pages for each module and function.","category":"page"}]
}
